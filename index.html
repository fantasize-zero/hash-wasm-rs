<!DOCTYPE html>
<html>
  <head>
    <title>Large File Hash WASM</title>
    <meta charset="utf-8" />
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .section {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      progress {
        width: 100%;
      }
      .hidden {
        display: none;
      }
      .performance {
        margin-top: 10px;
        padding: 10px;
        background-color: #f5f5f5;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h1>Large File Hash WebAssembly Demo</h1>

    <div class="section">
      <h2>File Hash Calculator</h2>
      <div>
        <label for="fileInput">Select a file:</label>
        <input type="file" id="fileInput" />
      </div>

      <div>
        <label for="fileAlgorithm">Algorithm:</label>
        <select id="fileAlgorithm">
          <option value="MD5">MD5</option>
          <option value="BLAKE3">BLAKE3</option>
          <option value="SHA256">SHA-256</option>
          <option value="SHA512">SHA-512</option>
          <option value="SHA3_256">SHA3-256</option>
          <option value="SHA3_512">SHA3-512</option>
        </select>
      </div>

      <div>
        <label for="chunkSize">Chunk Size (MB):</label>
        <select id="chunkSize">
          <option value="1">1 MB</option>
          <option value="2">2 MB</option>
          <option value="4" selected>4 MB</option>
          <option value="8">8 MB</option>
          <option value="16">16 MB</option>
          <option value="100">100 MB</option>
        </select>
      </div>

      <div>
        <label for="parallelMode">Processing Mode:</label>
        <select id="parallelMode">
          <option value="parallel">Parallel (Multi-threaded)</option>
          <option value="sequential">Sequential (Single-threaded)</option>
        </select>
      </div>

      <button id="hashFileBtn">Calculate File Hash</button>

      <div id="fileProgress" class="hidden">
        <p>Hashing file... <span id="progressPercent">0%</span></p>
        <progress id="hashProgress" value="0" max="100"></progress>
      </div>

      <div id="fileResult" class="hidden">
        <h3>Result:</h3>
        <p><strong>Hex:</strong> <span id="fileHashHex"></span></p>
          <strong>Bytes length:</strong> <span id="fileHashBytesLength"></span>
        </p>

        <div class="performance">
          <p><strong>Performance:</strong></p>
          <p><strong>File size:</strong> <span id="fileSize"></span></p>
          <p>
            <strong>Processing time:</strong>
            <span id="processingTime"></span> seconds
          </p>
          <p><strong>Speed:</strong> <span id="processingSpeed"></span> MB/s</p>
        </div>
      </div>
    </div>

    <script type="module">
      import initializeWasm,{
        HashType,
        HasherWrapper
      } from "./pkg-web/browser.js";

      await initializeWasm();

      class HashWorkerManager {
        constructor(workerCount = 4, hashType = HashType.MD5) {
          this.workerCount = workerCount;
          this.workers = [];
          this.pendingJobs = 0;
          this.results = [];
          this.resolve = null;
          this.reject = null;
          this.chunkIndex = 0;
          this.totalChunks = 0;
          this.file = null;
          this.chunkSize = 0;
          this.isProcessing = false;
          this.hashType = hashType;

          // 初始化 Workers
          for (let i = 0; i < workerCount; i++) {
            const worker = new Worker("./hash-worker.js");
            worker.onmessage = this.handleWorkerMessage.bind(this, i);
            worker.onerror = this.handleWorkerError.bind(this, i);
            this.workers.push({
              instance: worker,
              busy: false,
            });
          }
        }

        // 处理文件分片
        processFile(file, chunkSize = 1024 * 1024 * 10) {
          return new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            this.results = [];
            this.chunkIndex = 0;
            this.pendingJobs = 0;
            this.file = file;
            this.chunkSize = chunkSize;
            this.isProcessing = true;

            const fileSize = file.size;
            this.totalChunks = Math.ceil(fileSize / chunkSize);

            // 初始化结果数组
            this.results = new Array(this.totalChunks);

            // 开始处理分片
            this.processChunks();
          });
        }

        // 处理分片的核心方法
        processChunks() {
          const fileSize = this.file.size;
          let assignedChunks = 0;

          // 分配任务给空闲的Worker
          while (
            this.chunkIndex < this.totalChunks &&
            assignedChunks < this.workers.length * 2
          ) {
            const workerIndex = this.findIdleWorker();
            if (workerIndex === -1) break;

            const start = this.chunkIndex * this.chunkSize;
            const end = Math.min(start + this.chunkSize, fileSize);
            const chunk = this.file.slice(start, end);

            this.assignJob(workerIndex, chunk, this.chunkIndex);
            this.chunkIndex++;
            assignedChunks++;
          }

          // 检查是否所有分片都已处理
          if (this.chunkIndex >= this.totalChunks && this.pendingJobs === 0) {
            this.finalize();
          } else if (this.chunkIndex < this.totalChunks) {
            // 还有分片需要处理，设置延时继续处理
            setTimeout(() => this.processChunks(), 10);
          }
        }

        findIdleWorker() {
          for (let i = 0; i < this.workers.length; i++) {
            if (!this.workers[i].busy) {
              return i;
            }
          }
          return -1;
        }

        assignJob(workerIndex, chunk, chunkIndex) {
          const worker = this.workers[workerIndex];
          worker.busy = true;
          this.pendingJobs++;
          
          chunk
            .arrayBuffer()
            .then((arrayBuffer) => {
              worker.instance.postMessage(
                {
                  type: "process",
                  data: arrayBuffer,
                  index: chunkIndex,
                  hashType: this.hashType,
                },
                [arrayBuffer] // 传输所有权以提高性能
              );
            })
            .catch((error) => {
              console.error("Error reading chunk:", error);
              worker.busy = false;
              this.pendingJobs--;
              this.reject(new Error("Failed to read file chunk"));
            });
        }

        handleWorkerMessage(workerIndex, e) {
          const worker = this.workers[workerIndex];
          worker.busy = false;
          this.pendingJobs--;

          const data = e.data;
          if (data.type === "chunk_result") {
            this.results[data.index] = data.hash;

            // 继续处理下一个分片
            if (this.isProcessing) {
              this.processChunks();
            }
          } else if (data.type === "error") {
            this.isProcessing = false;
            this.reject(new Error(data.message));
          }
        }

        handleWorkerError(workerIndex, error) {
          console.error(`Worker ${workerIndex} error:`, error);
          this.workers[workerIndex].busy = false;
          this.pendingJobs--;
          this.isProcessing = false;
          this.reject(error);
        }



      async calculateHash(left, right) {
        let hasher = new HasherWrapper(this.hashType, left);
        if (right) {
          hasher = new HasherWrapper(this.hashType, left + right);
        }
        return await hasher.result();
      }

      async calculateFinalHash(chunkHashes) {
          let currentLevelNodes = [...chunkHashes] // 使用副本进行操作
          
          while (currentLevelNodes.length > 1) {
            let parentNodes = []
            for (let i = 0; i < currentLevelNodes.length; i += 2) {
              const leftNode = currentLevelNodes[i]
              const rightNode = i + 1 < currentLevelNodes.length ? currentLevelNodes[i + 1] : null

              try {
                const parentResult = await this.calculateHash(
                  leftNode,
                  rightNode,
                )

                parentNodes.push(parentResult.hex)
              } catch (error) {
                throw new Error(`计算父节点哈希失败: ${error}`)
              }
            }
            currentLevelNodes = parentNodes
          }
          return currentLevelNodes[0];
        }

        finalize() {
          this.isProcessing = false;

          // 检查是否所有分片都有结果
          const allResultsPresent = this.results.every(
            (result) => result !== undefined
          );
          if (!allResultsPresent) {
            this.reject(new Error("Not all chunks were processed"));
            return;
          }

          // 根据results计算完整哈希
          this.calculateFinalHash(this.results).then((fullHash) => {
            this.resolve({
              hex: fullHash,
              chunkHashes: this.results,
            });
          })
        }

        terminate() {
          this.isProcessing = false;
          this.workers.forEach((worker) => worker.instance.terminate());
        }
      }

      async function hashFileWithWorkers(file) {
        const algorithm = document.getElementById("fileAlgorithm").value;
        const workerCount = navigator.hardwareConcurrency || 4;
        const workerManager = new HashWorkerManager(workerCount, HashType[algorithm]);
        console.log("Worker count:", workerCount);

        try {
          const result = await workerManager.processFile(file);
          console.log("Full file hash:", result.hex);
          console.log("Chunk hashes:", result.chunkHashes);
          return result;
        } finally {
          workerManager.terminate();
        }
      }
      
     
      document
        .getElementById("hashFileBtn")
        .addEventListener("click", async function () {
          const fileInput = document.getElementById("fileInput");
          const algorithm = document.getElementById("fileAlgorithm").value;
          const chunkSize =
            parseInt(document.getElementById("chunkSize").value) * 1024 * 1024;
          const parallelMode = document.getElementById("parallelMode").value;

          if (fileInput.files.length === 0) {
            alert("请先选择文件");
            return;
          }

          const file = fileInput.files[0];
          const progressDiv = document.getElementById("fileProgress");
          const resultDiv = document.getElementById("fileResult");

          progressDiv.classList.remove("hidden");
          resultDiv.classList.add("hidden");

          const startTime = performance.now();

          try {
            let result;
            if (parallelMode === "parallel") {
              result = await hashFileWithWorkers(file);
            } else {
              result = await new HasherWrapper(HashType[algorithm], file).result()
            }

            const endTime = performance.now();
            const processingTime = (endTime - startTime) / 1000;
            const fileSizeMB = file.size / (1024 * 1024);
            const speed = fileSizeMB / processingTime;

            document.getElementById("fileHashHex").textContent = result.hex;

            document.getElementById("fileSize").textContent =
              fileSizeMB.toFixed(2) + " MB";
            document.getElementById("processingTime").textContent =
              processingTime.toFixed(2);
            document.getElementById("processingSpeed").textContent =
              speed.toFixed(2);
            progressDiv.classList.add("hidden");
            resultDiv.classList.remove("hidden");
          } catch (error) {
            console.error("文件哈希计算错误:", error);
            console.error("文件哈希计算错误: " + error.message);
            progressDiv.classList.add("hidden");
          }
        });
    </script>
  </body>
</html>
